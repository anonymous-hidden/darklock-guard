/**
 * DARKLOCK AUTH.JS DATABASE MIGRATION PATCHES
 * Apply these changes to convert from JSON to SQLite
 * 
 * File: darklock/routes/auth.js
 */

// ============================================
// PATCH 1: Update signup endpoint (around line 280-400)
// ============================================
// FIND (after password validation):
/*
        // Load existing users
        const usersData = await loadUsers();
        
        // Check for existing username (case-insensitive)
        const existingUsername = usersData.users.find(
            u => u.username.toLowerCase() === username.toLowerCase()
        );
        if (existingUsername) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Username is already taken'
            });
        }
        
        // Check for existing email (case-insensitive)
        const existingEmail = usersData.users.find(
            u => u.email.toLowerCase() === email.toLowerCase()
        );
        if (existingEmail) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Email is already registered'
            });
        }
        
        // Hash password with bcrypt (cost factor 12)
        const hashedPassword = await bcrypt.hash(password, 12);
        
        // Create new user
        const newUser = {
            id: crypto.randomUUID(),
            username: username.trim(),
            email: email.toLowerCase().trim(),
            password: hashedPassword,
            role: usersData.users.length === 0 ? 'admin' : 'user',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            twoFactorEnabled: false,
            twoFactorSecret: null,
            avatar: null,
            lastLogin: new Date().toISOString(),
            lastLoginIp: getClientIP(req),
            passwordChangedAt: new Date().toISOString(),
            settings: {
                theme: 'dark',
                notifications: true
            }
        };
        
        // Save user
        usersData.users.push(newUser);
        if (!await saveUsers(usersData)) {
            return res.status(500).json({
                success: false,
                error: 'Failed to create account. Please try again.'
            });
        }
*/

// REPLACE WITH:
        // Check for existing username (case-insensitive)
        const existingUsername = await db.getUserByUsername(username);
        if (existingUsername) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Username is already taken'
            });
        }
        
        // Check for existing email (case-insensitive)
        const existingEmail = await db.getUserByEmail(email);
        if (existingEmail) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Email is already registered'
            });
        }
        
        // Hash password with bcrypt (cost factor 12)
        const hashedPassword = await bcrypt.hash(password, 12);
        
        // Determine role (first user is admin)
        const userCount = await db.all('SELECT COUNT(*) as count FROM users');
        const role = userCount[0].count === 0 ? 'admin' : 'user';
        
        // Create new user
        const newUser = await db.createUser({
            id: crypto.randomUUID(),
            username: username.trim(),
            email: email.toLowerCase().trim(),
            password: hashedPassword,
            displayName: username.trim(), // Set initial displayName
            role: role,
            settings: {
                theme: 'dark',
                notifications: true
            }
        });
        
        if (!newUser) {
            return res.status(500).json({
                success: false,
                error: 'Failed to create account. Please try again.'
            });
        }

// ============================================
// PATCH 2: Update login endpoint (around line 400-500)
// ============================================
// FIND:
/*
        const usersData = await loadUsers();
        
        // Find user by username or email
        const user = usersData.users.find(
            u => u.username.toLowerCase() === usernameOrEmail.toLowerCase() ||
                 u.email.toLowerCase() === usernameOrEmail.toLowerCase()
        );
        
        if (!user) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }
        
        // Verify password
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }
*/

// REPLACE WITH:
        // Find user by username or email
        let user = await db.getUserByUsername(usernameOrEmail);
        if (!user) {
            user = await db.getUserByEmail(usernameOrEmail);
        }
        
        if (!user) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }
        
        // Verify password
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

// ============================================
// PATCH 3: Update session creation (around line 460-480)
// ============================================
// FIND:
/*
        // Generate JWT with jti and 2FA verification status
        const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
        const jti = generateJti();
        const token = generateToken(user, secret, jti, twoFactorVerified);
        
        // Create session record
        await createSession(user.id, jti, req);
        
        // Update last login info
        user.lastLogin = new Date().toISOString();
        user.lastLoginIp = getClientIP(req);
        await saveUsers(usersData);
*/

// REPLACE WITH:
        // Generate JWT with jti and 2FA verification status
        const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
        const jti = generateJti();
        const token = generateToken(user, secret, jti, twoFactorVerified);
        
        // Create session record in database
        await db.createSession({
            id: crypto.randomUUID(),
            jti: jti,
            userId: user.id,
            ip: getClientIP(req),
            userAgent: req.headers['user-agent'] || '',
            device: parseUserAgent(req.headers['user-agent'])
        });
        
        // Update last login info
        await db.updateUser(user.id, {
            lastLogin: new Date().toISOString(),
            lastLoginIp: getClientIP(req)
        });

// ============================================
// PATCH 4: Update logout endpoint (around line 510-540)
// ============================================
// FIND:
/*
        const token = req.cookies?.darklock_token;
        
        if (token) {
            const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
            try {
                const decoded = jwt.verify(token, secret);
                
                // Revoke the session by jti
                const sessionsData = await loadSessions();
                const session = sessionsData.sessions.find(s => s.jti === decoded.jti);
                if (session) {
                    session.revokedAt = new Date().toISOString();
                    await saveSessions(sessionsData);
                }
            } catch (err) {
                // Token invalid, just clear cookie
            }
        }
*/

// REPLACE WITH:
        const token = req.cookies?.darklock_token;
        
        if (token) {
            const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
            try {
                const decoded = jwt.verify(token, secret);
                
                // Revoke the session by jti
                await db.revokeSession(decoded.jti);
            } catch (err) {
                // Token invalid, just clear cookie
            }
        }

// ============================================
// PATCH 5: Update /me endpoint (around line 550-600)
// ============================================
// FIND:
/*
        const usersData = await loadUsers();
        const user = usersData.users.find(u => u.id === decoded.userId);
        
        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
*/

// REPLACE WITH:
        const user = await db.getUserById(decoded.userId);
        
        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Get user settings
        const settings = await db.getUserSettings(decoded.userId);

// ============================================
// PATCH 6: Update return object in /me endpoint
// ============================================
// ADD to the response object (merge with settings):
/*
        res.json({
            success: true,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                displayName: user.display_name || user.username, // <-- ADD THIS
                role: user.role,
                avatar: user.avatar,
                twoFactorEnabled: user.two_factor_enabled === 1, // <-- Convert to boolean
                twoFactorVerified: decoded.twoFactorVerified,
                createdAt: user.created_at,
                lastLogin: user.last_login,
                settings: user.settings,
                // ADD extended settings from user_settings table:
                notificationsEnabled: settings?.notifications_enabled === 1,
                emailAlertsEnabled: settings?.email_alerts_enabled === 1,
                securityAlertsEnabled: settings?.security_alerts_enabled === 1,
                sessionTimeoutMinutes: settings?.session_timeout_minutes || 1440,
                uiCompactMode: settings?.ui_compact_mode === 1,
                showQuickActions: settings?.show_quick_actions === 1,
                theme: settings?.theme || 'dark',
                language: settings?.language || 'en'
            }
        });
*/

// ============================================
// PATCH 7: Remove JSON functions (top of file after imports)
// ============================================
// DELETE these functions completely:
// - async function loadUsers()
// - async function saveUsers(data)
// - async function loadSessions()
// - async function saveSessions(data)
// - async function createSession(userId, jti, req)

// NOTE: createSession is now handled by db.createSession()

// ============================================
// PATCH 8: Update generateToken function signature
// ============================================
// This function should remain the same, but verify it's using correct fields:
/*
function generateToken(user, secret, jti, twoFactorVerified = false, expiresIn = '7d') {
    return jwt.sign(
        {
            userId: user.id,
            username: user.username,
            email: user.email,
            role: user.role || 'user',
            twoFactorVerified,
            jti
        },
        secret,
        { expiresIn }
    );
}
*/

// ============================================
// END OF PATCHES
// ============================================

/*
DEPLOYMENT INSTRUCTIONS:
1. Run migration script: node scripts/migrate-darklock-to-sqlite.js
2. Apply these patches to darklock/routes/auth.js
3. Update darklock/server.js to initialize database on startup
4. Set environment variable: DARKLOCK_DB_PATH=/data/darklock.db
5. Restart server
6. Verify /platform/auth/me returns correct data
7. Test login/logout/signup flows
8. Backup users.json before removing
*/
