###############################################################################
# UNIFIED PATCH FILE - Production Bug Fixes
# Apply these patches in order
# Date: January 11, 2026
# Engineer: Claude Sonnet 4.5
###############################################################################

###############################################################################
# PATCH 1: Discord OAuth Redirect Fix
# File: src/dashboard/routes/auth.js
# Status: ✅ ALREADY APPLIED
###############################################################################
--- a/src/dashboard/routes/auth.js
+++ b/src/dashboard/routes/auth.js
@@ -251,7 +251,14 @@
                 maxAge: 24 * 60 * 60 * 1000
             });
 
-            res.redirect(`${redirectUrl}/dashboard.html`);
+            // Role-based redirect: admins go to admin dashboard, regular users to user dashboard
+            if (role === 'owner' || role === 'admin') {
+                this.bot.logger?.info(`Discord OAuth: Redirecting ${role} user ${discordUser.username} to admin dashboard`);
+                res.redirect(`${redirectUrl}/admin/dashboard.html`);
+            } else {
+                this.bot.logger?.info(`Discord OAuth: Redirecting user ${discordUser.username} to user dashboard`);
+                res.redirect(`${redirectUrl}/dashboard.html`);
+            }
 
         } catch (error) {
             this.bot.logger?.error('Discord OAuth error:', error);

###############################################################################
# PATCH 2: Darklock Server Database Initialization
# File: darklock/server.js
# Status: ✅ ALREADY APPLIED
###############################################################################
--- a/darklock/server.js
+++ b/darklock/server.js
@@ -6,6 +6,9 @@
 const cors = require('cors');
 const rateLimit = require('express-rate-limit');
 
+// Database initialization
+const db = require('./utils/database');
+
 // Import routes
 const authRoutes = require('./routes/auth');
 const { router: dashboardRoutes } = require('./routes/dashboard');
@@ -373,9 +376,23 @@
     /**
      * Start standalone server
      */
-    start() {
-        return new Promise((resolve, reject) => {
+    async start() {
+        return new Promise(async (resolve, reject) => {
             try {
+                // Initialize database before starting server
+                console.log('[Darklock Platform] Initializing database...');
+                await db.initialize();
+                
+                // Run session cleanup on startup
+                await db.cleanupExpiredSessions();
+                
+                // Schedule periodic cleanup (every hour)
+                setInterval(async () => {
+                    try {
+                        await db.cleanupExpiredSessions();
+                    } catch (err) {
+                        console.error('[Darklock Platform] Session cleanup error:', err);
+                    }
+                }, 60 * 60 * 1000);
+                
                 this.server = this.app.listen(this.port, () => {
-                    console.log(`[Darklock Platform] Server running on port ${this.port}`);
+                    console.log(`[Darklock Platform] ✅ Server running on port ${this.port}`);
                     console.log(`[Darklock Platform] Homepage: http://localhost:${this.port}/platform`);

###############################################################################
# PATCH 3: Darklock Auth Routes Header
# File: darklock/routes/auth.js
# Status: ⏳ PENDING APPLICATION
###############################################################################
--- a/darklock/routes/auth.js
+++ b/darklock/routes/auth.js
@@ -3,72 +3,24 @@
  * Handles user registration, login, logout, and session management
  * Uses bcrypt for password hashing and JWT for session tokens
  * 
+ * UPDATED: Now uses SQLite database instead of JSON files for persistence
+ * 
  * Security Features:
  * - JWT with jti (JWT ID) for session invalidation
- * - Atomic file writes with locking
+ * - Persistent SQLite storage on /data volume
  * - Rate limiting on sensitive endpoints
  * - Session tracking with IP/device info
  * - All sessions invalidated on password change
  */
 
 const express = require('express');
 const router = express.Router();
 const bcrypt = require('bcrypt');
 const jwt = require('jsonwebtoken');
 const crypto = require('crypto');
 const path = require('path');
 const speakeasy = require('speakeasy');
-const fs = require('fs');
+
+// Database (SQLite)
+const db = require('../utils/database');
 
 // Email service
 const emailService = require('../utils/email');
 
 // Security utilities
 const {
-    atomicWriteJSON,
-    safeReadJSON,
     rateLimitMiddleware,
     generateJti,
     isSessionValid,
     revokeUserSessions,
     cleanupSessions
 } = require('../utils/security');
-
-// Data persistence path (Render /data volume compatible)
-const DATA_DIR = process.env.DATA_PATH || path.join(__dirname, '../data');
-const USERS_FILE = path.join(DATA_DIR, 'users.json');
-const SESSIONS_FILE = path.join(DATA_DIR, 'sessions.json');
-
-// Ensure data directory exists
-if (!fs.existsSync(DATA_DIR)) {
-    fs.mkdirSync(DATA_DIR, { recursive: true });
-}
-
-// Initialize files if they don't exist
-if (!fs.existsSync(USERS_FILE)) {
-    fs.writeFileSync(USERS_FILE, JSON.stringify({ users: [] }, null, 2));
-}
-if (!fs.existsSync(SESSIONS_FILE)) {
-    fs.writeFileSync(SESSIONS_FILE, JSON.stringify({ sessions: [] }, null, 2));
-}
-
-/**
- * Load users from persistent storage (async)
- */
-async function loadUsers() {
-    return await safeReadJSON(USERS_FILE, { users: [] });
-}
-
-/**
- * Save users to persistent storage (atomic)
- */
-async function saveUsers(data) {
-    try {
-        await atomicWriteJSON(USERS_FILE, data);
-        return true;
-    } catch (err) {
-        console.error('[Darklock Auth] Error saving users:', err.message);
-        return false;
-    }
-}
-
-/**
- * Load sessions from persistent storage (async)
- */
-async function loadSessions() {
-    return await safeReadJSON(SESSIONS_FILE, { sessions: [] });
-}
-
-/**
- * Save sessions to persistent storage (atomic)
- */
-async function saveSessions(data) {
-    try {
-        await atomicWriteJSON(SESSIONS_FILE, data);
-        return true;
-    } catch (err) {
-        console.error('[Darklock Auth] Error saving sessions:', err.message);
-        return false;
-    }
-}

###############################################################################
# PATCH 4: Darklock Auth Signup - Database Integration
# File: darklock/routes/auth.js
# Line: ~340-390 (in signup endpoint after validation)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
        // Load existing users
        const usersData = await loadUsers();
        
        // Check for existing username (case-insensitive)
        const existingUsername = usersData.users.find(
            u => u.username.toLowerCase() === username.toLowerCase()
        );
        if (existingUsername) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Username is already taken'
            });
        }
        
        // Check for existing email (case-insensitive)
        const existingEmail = usersData.users.find(
            u => u.email.toLowerCase() === email.toLowerCase()
        );
        if (existingEmail) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Email is already registered'
            });
        }
        
        // Hash password with bcrypt (cost factor 12)
        const hashedPassword = await bcrypt.hash(password, 12);
        
        // Create new user
        const newUser = {
            id: crypto.randomUUID(),
            username: username.trim(),
            email: email.toLowerCase().trim(),
            password: hashedPassword,
            role: usersData.users.length === 0 ? 'admin' : 'user',
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            twoFactorEnabled: false,
            twoFactorSecret: null,
            avatar: null,
            lastLogin: new Date().toISOString(),
            lastLoginIp: getClientIP(req),
            passwordChangedAt: new Date().toISOString(),
            settings: {
                theme: 'dark',
                notifications: true
            }
        };
        
        // Save user
        usersData.users.push(newUser);
        if (!await saveUsers(usersData)) {
            return res.status(500).json({
                success: false,
                error: 'Failed to create account. Please try again.'
            });
        }

// REPLACE WITH:
        // Check for existing username (case-insensitive)
        const existingUsername = await db.getUserByUsername(username);
        if (existingUsername) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Username is already taken'
            });
        }
        
        // Check for existing email (case-insensitive)
        const existingEmail = await db.getUserByEmail(email);
        if (existingEmail) {
            req.recordAttempt(false);
            return res.status(400).json({
                success: false,
                error: 'Email is already registered'
            });
        }
        
        // Hash password with bcrypt (cost factor 12)
        const hashedPassword = await bcrypt.hash(password, 12);
        
        // Determine role (first user is admin)
        const userCount = await db.all('SELECT COUNT(*) as count FROM users');
        const role = userCount[0].count === 0 ? 'admin' : 'user';
        
        // Create new user
        const newUser = await db.createUser({
            id: crypto.randomUUID(),
            username: username.trim(),
            email: email.toLowerCase().trim(),
            password: hashedPassword,
            displayName: username.trim(), // Set initial displayName
            role: role,
            settings: {
                theme: 'dark',
                notifications: true
            }
        });
        
        if (!newUser) {
            return res.status(500).json({
                success: false,
                error: 'Failed to create account. Please try again.'
            });
        }

###############################################################################
# PATCH 5: Darklock Auth Login - Database Integration
# File: darklock/routes/auth.js
# Line: ~430-450 (in login endpoint)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
        const usersData = await loadUsers();
        
        // Find user by username or email
        const user = usersData.users.find(
            u => u.username.toLowerCase() === usernameOrEmail.toLowerCase() ||
                 u.email.toLowerCase() === usernameOrEmail.toLowerCase()
        );
        
        if (!user) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }
        
        // Verify password
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

// REPLACE WITH:
        // Find user by username or email
        let user = await db.getUserByUsername(usernameOrEmail);
        if (!user) {
            user = await db.getUserByEmail(usernameOrEmail);
        }
        
        if (!user) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }
        
        // Verify password
        const validPassword = await bcrypt.compare(password, user.password);
        if (!validPassword) {
            req.recordAttempt(false);
            return res.status(401).json({
                success: false,
                error: 'Invalid credentials'
            });
        }

###############################################################################
# PATCH 6: Darklock Auth Login Session Creation - Database Integration
# File: darklock/routes/auth.js
# Line: ~475-485 (in login endpoint after 2FA)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
        // Generate JWT with jti and 2FA verification status
        const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
        const jti = generateJti();
        const token = generateToken(user, secret, jti, twoFactorVerified);
        
        // Create session record
        await createSession(user.id, jti, req);
        
        // Update last login info
        user.lastLogin = new Date().toISOString();
        user.lastLoginIp = getClientIP(req);
        await saveUsers(usersData);

// REPLACE WITH:
        // Generate JWT with jti and 2FA verification status
        const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
        const jti = generateJti();
        const token = generateToken(user, secret, jti, twoFactorVerified);
        
        // Create session record in database
        await db.createSession({
            id: crypto.randomUUID(),
            jti: jti,
            userId: user.id,
            ip: getClientIP(req),
            userAgent: req.headers['user-agent'] || '',
            device: parseUserAgent(req.headers['user-agent'])
        });
        
        // Update last login info
        await db.updateUser(user.id, {
            lastLogin: new Date().toISOString(),
            lastLoginIp: getClientIP(req)
        });

###############################################################################
# PATCH 7: Darklock Auth Logout - Database Integration
# File: darklock/routes/auth.js
# Line: ~515-535 (in logout endpoint)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
        const token = req.cookies?.darklock_token;
        
        if (token) {
            const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
            try {
                const decoded = jwt.verify(token, secret);
                
                // Revoke the session by jti
                const sessionsData = await loadSessions();
                const session = sessionsData.sessions.find(s => s.jti === decoded.jti);
                if (session) {
                    session.revokedAt = new Date().toISOString();
                    await saveSessions(sessionsData);
                }
            } catch (err) {
                // Token invalid, just clear cookie
            }
        }

// REPLACE WITH:
        const token = req.cookies?.darklock_token;
        
        if (token) {
            const secret = process.env.JWT_SECRET || 'darklock-secret-key-change-in-production';
            try {
                const decoded = jwt.verify(token, secret);
                
                // Revoke the session by jti
                await db.revokeSession(decoded.jti);
            } catch (err) {
                // Token invalid, just clear cookie
            }
        }

###############################################################################
# PATCH 8: Darklock Auth /me Endpoint - Database Integration
# File: darklock/routes/auth.js
# Line: ~570-600 (in /me endpoint)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
        const usersData = await loadUsers();
        const user = usersData.users.find(u => u.id === decoded.userId);
        
        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        res.json({
            success: true,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                role: user.role,
                avatar: user.avatar,
                displayName: user.displayName || null,
                // ... rest of fields
            }
        });

// REPLACE WITH:
        const user = await db.getUserById(decoded.userId);
        
        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Get user settings
        const settings = await db.getUserSettings(decoded.userId);
        
        res.json({
            success: true,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                displayName: user.display_name || user.username, // Fixed: use DB field
                role: user.role,
                avatar: user.avatar,
                twoFactorEnabled: user.two_factor_enabled === 1, // Convert to boolean
                twoFactorVerified: decoded.twoFactorVerified,
                createdAt: user.created_at,
                lastLogin: user.last_login,
                settings: user.settings,
                // Extended settings from user_settings table:
                notificationsEnabled: settings?.notifications_enabled === 1,
                emailAlertsEnabled: settings?.email_alerts_enabled === 1,
                securityAlertsEnabled: settings?.security_alerts_enabled === 1,
                sessionTimeoutMinutes: settings?.session_timeout_minutes || 1440,
                uiCompactMode: settings?.ui_compact_mode === 1,
                showQuickActions: settings?.show_quick_actions === 1,
                theme: settings?.theme || 'dark',
                language: settings?.language || 'en'
            }
        });

###############################################################################
# PATCH 9: Darklock Auth Session Endpoints - Database Integration
# File: darklock/routes/auth.js
# Line: ~620-650 (in /sessions endpoint)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
        const sessionsData = await loadSessions();
        
        // Get user's non-revoked sessions
        const userSessions = sessionsData.sessions
            .filter(s => s.userId === decoded.userId && !s.revokedAt)
            .map(s => ({
                id: s.id,
                device: s.device,
                ip: s.ip,
                lastActive: s.lastActive,
                createdAt: s.createdAt,
                current: s.jti === decoded.jti
            }))
            .sort((a, b) => new Date(b.lastActive) - new Date(a.lastActive));

// REPLACE WITH:
        // Get user's non-revoked sessions from database
        const userSessions = await db.getUserSessions(decoded.userId);
        
        const sessions = userSessions.map(s => ({
            id: s.id,
            device: s.device,
            ip: s.ip,
            lastActive: s.last_active,
            createdAt: s.created_at,
            current: s.jti === decoded.jti
        }));

###############################################################################
# PATCH 10: Module Exports Update
# File: darklock/routes/auth.js
# Line: ~800+ (at end of file)
# Status: ⏳ PENDING APPLICATION
###############################################################################

// FIND THIS BLOCK:
module.exports = router;
module.exports.loadUsers = loadUsers;
module.exports.saveUsers = saveUsers;
module.exports.loadSessions = loadSessions;
module.exports.saveSessions = saveSessions;
module.exports.verifyToken = verifyToken;
module.exports.revokeUserSessions = revokeUserSessions;
module.exports.getClientIP = getClientIP;

// REPLACE WITH:
module.exports = router;
module.exports.verifyToken = verifyToken;
module.exports.revokeUserSessions = revokeUserSessions;
module.exports.getClientIP = getClientIP;
// Note: loadUsers, saveUsers, loadSessions, saveSessions removed (now use db)

###############################################################################
# END OF PATCHES
###############################################################################

DEPLOYMENT ORDER:
1. ✅ PATCH 1 - Already applied
2. ✅ PATCH 2 - Already applied
3. ⏳ PATCH 3-10 - Apply to darklock/routes/auth.js
4. Create new files (database.js, migration script) - Already created
5. Run migration script
6. Deploy to Render
7. Test password persistence

FILES TO CREATE (already created):
- darklock/utils/database.js
- scripts/migrate-darklock-to-sqlite.js

CRITICAL ENVIRONMENT VARIABLES:
DARKLOCK_DB_PATH=/data/darklock.db
JWT_SECRET=<generate-secure-random>
NODE_ENV=production

RENDER REQUIREMENTS:
- Persistent disk mounted at /data (512MB minimum)
- Environment variables configured
- Auto-deploy enabled or manual trigger ready

TEST AFTER DEPLOYMENT:
1. Create account
2. Login
3. Trigger Render restart
4. Login again with same credentials
5. ✅ PASS: Login works after restart
6. ❌ FAIL: Invalid credentials - DO NOT DEPLOY
